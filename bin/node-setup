#!/usr/bin/env node
'use strict'

const { promisify } = require('util')
const { spawn } = require('child_process')
const fs = require('fs')
const path = require('path')

const fsMkdir = promisify(fs.mkdir.bind(fs))
const fsWriteFile = promisify(fs.writeFile.bind(fs))

const fileTag = (strings, ...exprs) => {
  const endResult = strings
    .reduce((str, part, i) => str + exprs[i - 1] + part)
    .replace(/^\n/, '')
  const match = endResult.match(/^[^\S\n]*(?=\S)/gm)
  const indent = match && Math.min(...match.map(el => el.length))
  if (indent) {
    const regexp = new RegExp(`^.{${indent}}`, 'gm')
    return endResult.replace(regexp, '')
  }
  return endResult
}

const spawnPromise = (command, args) => {
  const fullCommand = `${command} ${args.join(' ')}`
  return new Promise((resolve, reject) => {
    const running = spawn(command, args, { stdio: 'inherit' })
    running.on('close', code => {
      return code === 0
        ? resolve()
        : reject(new Error(`Exit code ${exitCode}: ${fullCommand}`))
    })
  })
}

const installDependencies = (yarn, dev, dependencies) => {
  const command = yarn ? 'yarn' : 'npm'
  const installCommand = yarn ? 'add' : 'install'
  const devFlag = yarn ? '--dev' : '--save-dev'
  const args = [installCommand]
  if (dev) args.push(devFlag)
  const fullCommand = `${command} ${installCommand} ... ${args.join(' ')}`
  args.push(...dependencies)
  return spawnPromise(command, args)
}

const writeFile = async (filepath, contents) => {
  const dirname = path.dirname(filepath)
  await fsMkdir(dirname, { recursive: true, mode: 0o755 })
  if (typeof contents === 'object') {
    contents = JSON.stringify(contents, null, 2)
  }
  contents += '\n'
  await fsWriteFile(filepath, contents, { mode: 0o644 })
}

const writeFiles = files =>
  Promise.all(
    Object.entries(files).map(([filepath, contents]) =>
      writeFile(filepath, contents)
    )
  )

const help = (exitCode = 0) => {
  console.error(`  node-setup [options]

  Options:
    --help, -h    Display help information
    --debug       Adds vscode debug configs
    --docker      Puts Dockerfiles in project
    --git         Adds git support
    --lint        Adds lint support to the project
    --test        Adds testing
    --typescript  Add typescript support to the project
    --yarn        Install dependencies with yarn instead of npm
    --all         Sets all the flags
`)
  process.exit(exitCode)
}

const options = process.argv.slice(2).reduce(
  (options, arg) => {
    let valToSet = true
    if (arg.startsWith('--no-')) {
      valToSet = false
      arg = arg.replace(/^--no-/, '--')
    }
    switch (arg) {
      case '--help':
      case '-h':
      case 'help':
        return help()
      case '--debug':
        return { ...options, debug: valToSet }
      case '--docker':
        return { ...options, docker: valToSet }
      case '--git':
        return { ...options, git: valToSet }
      case '--lint':
        return { ...options, lint: valToSet }
      case '--test':
        return { ...options, test: valToSet }
      case '--typescript':
        return { ...options, typescript: valToSet }
      case '--yarn':
        return { ...options, yarn: valToSet }
      case '--all':
        return {
          ...options,
          debug: valToSet,
          docker: valToSet,
          git: valToSet,
          lint: valToSet,
          test: valToSet,
          typescript: valToSet,
          yarn: valToSet
        }
    }
    console.error(`Unknown arg "${arg}"`)
    return help(1)
  },
  {
    name: path.basename(process.cwd()),
    debug: false,
    docker: false,
    git: false,
    lint: false,
    test: false,
    typescript: false,
    yarn: false
  }
)

const files = {}
files['package.json'] = {
  name: options.name,
  description: '',
  version: '0.0.0',
  main: 'src/index.js',
  bin: undefined,
  license: 'MIT',
  private: true,
  scripts: {
    build: undefined,
    format: undefined,
    lint: undefined,
    start: 'node .',
    'start.dev': `nodemon ${options.debug ? '--inspect=0.0.0.0:9229 ' : ''}`,
    test: undefined
  },
  dependencies: {},
  devDependencies: {}
}
const dependencies = new Set()
const devDependencies = new Set()
const genericIgnore = fileTag`
  # Created by https://www.gitignore.io/api/node,visualstudiocode,macos,linux
  # Edit at https://www.gitignore.io/?templates=node,visualstudiocode,macos,linux

  ### Linux ###
  *~

  # temporary files which can be created if a process still has a handle open of a deleted file
  .fuse_hidden*

  # KDE directory preferences
  .directory

  # Linux trash folder which might appear on any partition or disk
  .Trash-*

  # .nfs files are created when an open file is removed but is still being accessed
  .nfs*

  ### macOS ###
  # General
  .DS_Store
  .AppleDouble
  .LSOverride

  # Icon must end with two \\r
  Icon

  # Thumbnails
  ._*

  # Files that might appear in the root of a volume
  .DocumentRevisions-V100
  .fseventsd
  .Spotlight-V100
  .TemporaryItems
  .Trashes
  .VolumeIcon.icns
  .com.apple.timemachine.donotpresent

  # Directories potentially created on remote AFP share
  .AppleDB
  .AppleDesktop
  Network Trash Folder
  Temporary Items
  .apdisk

  ### Node ###
  # Logs
  logs
  *.log
  npm-debug.log*
  yarn-debug.log*
  yarn-error.log*

  # Runtime data
  pids
  *.pid
  *.seed
  *.pid.lock

  # Directory for instrumented libs generated by jscoverage/JSCover
  lib-cov

  # Coverage directory used by tools like istanbul
  coverage

  # nyc test coverage
  .nyc_output

  # Grunt intermediate storage (https://gruntjs.com/creating-plugins#storing-task-files)
  .grunt

  # Bower dependency directory (https://bower.io/)
  bower_components

  # node-waf configuration
  .lock-wscript

  # Compiled binary addons (https://nodejs.org/api/addons.html)
  build/Release

  # Dependency directories
  node_modules/
  jspm_packages/

  # TypeScript v1 declaration files
  typings/

  # Optional npm cache directory
  .npm

  # Optional eslint cache
  .eslintcache

  # Optional REPL history
  .node_repl_history

  # Output of 'npm pack'
  *.tgz

  # Yarn Integrity file
  .yarn-integrity

  # dotenv environment variables file
  .env
  .env.test

  # parcel-bundler cache (https://parceljs.org/)
  .cache

  # next.js build output
  .next

  # nuxt.js build output
  .nuxt

  # vuepress build output
  .vuepress/dist

  # Serverless directories
  .serverless/

  # FuseBox cache
  .fusebox/

  # DynamoDB Local files
  .dynamodb/

  ### VisualStudioCode ###
  .vscode/*
  !.vscode/settings.json
  !.vscode/tasks.json
  !.vscode/launch.json
  !.vscode/extensions.json

  ### VisualStudioCode Patch ###
  # Ignore all local history of files
  .history

  # End of https://www.gitignore.io/api/node,visualstudiocode,macos,linux
`

devDependencies.add('nodemon')
files['src/index.js'] = fileTag`'use strict'`
files['README.md'] = fileTag`# ${options.name}`

if (options.git) {
  files['.gitignore'] = genericIgnore
}

/**
 * For setting up eslint standard for no conflict on eslint
 *  eslint \
 *  eslint-config-standard \
 *  eslint-config-standard-jsx \
 *  eslint-plugin-import \
 *  eslint-plugin-node \
 *  eslint-plugin-promise \
 *  eslint-plugin-react \
 *  eslint-plugin-standard
 */
if (options.lint) {
  devDependencies
    .add('eslint')
    .add('eslint-config-standard')
    .add('eslint-plugin-import')
    .add('eslint-plugin-node')
    .add('eslint-plugin-promise')
    .add('eslint-plugin-standard')
    .add('prettier-eslint-cli')
  const ext = options.typescript ? 'ts' : 'js'
  files['.eslintrc'] = {
    extends: ['standard']
  }
  Object.assign(files['package.json'].scripts, {
    format: `prettier-eslint 'src/**/*.${ext}' --write`,
    lint: `eslint 'src/**/*.${ext}' && prettier-eslint 'src/**/*.${ext}' --list-different`
  })
  if (options.typescript) {
    devDependencies.add('@typescript-eslint/parser')
    files['.eslintrc'].parser = '@typescript-eslint/parser'
  }
}

if (options.typescript) {
  delete files['src/index.js']
  const outDir = `dist`
  const newMain = 'src/index.ts'
  files['package.json'].main = `${outDir}/index.js`
  Object.assign(files['package.json'].scripts, {
    build: 'tsc',
    'start.dev': `nodemon ${
      options.debug ? '--inspect=0.0.0.0:9229 ' : ''
    }-r ts-node/register ${newMain}`
  })
  dependencies.add('typescript').add('@types/node')
  devDependencies.add('ts-node')
  files[newMain] = ``
  files['tsconfig.json'] = {
    compilerOptions: {
      module: 'commonjs',
      esModuleInterop: true,
      target: 'esnext',
      alwaysStrict: true,
      strict: true,
      sourceMap: true,
      outDir
    },
    include: ['src/**/*'],
    exclude: ['node_modules', '**/*.test.ts', '**/*.spec.ts', '**/__tests__/**']
  }
}

if (options.docker) {
  files['package.json'].bin = files['package.json'].main
  files['.dockerignore'] = genericIgnore
  files['Dockerfile'] = fileTag`
    FROM node:10-alpine as base

    ENV NODE node10
    ENV PLATFORM alpine
    ENV ARCH x64

    # Needed for git dependency
    # RUN apk --no-cache add --virtual git
    # Needed for bcrypt
    # RUN apk --no-cache add --virtual builds-deps build-base python
    # Get pkg packages
    RUN yarn global add pkg pkg-fetch
    RUN pkg-fetch \${NODE} \${PLATFORM} \${ARCH}

    # Create app directory
    RUN mkdir -p /usr/src/app
    WORKDIR /usr/src/app

    # Install dependencies
    COPY package*.json ./
    ${options.yarn ? 'COPY yarn.lock .' : ''}
    RUN ${options.yarn ? 'yarn' : 'npm install'} --production

    # Bundle app source
    COPY . .
    ${
      options.typescript
        ? `RUN ${options.yarn ? 'yarn' : 'npm run'} build\n`
        : ''
    }
    # Build assets
    RUN pkg package.json --targets "\${NODE}-\${PLATFORM}-\${ARCH}" --output start

    # --- Release with Alpine ----
    FROM alpine

    # Needed for the executable
    RUN apk --no-cache add --virtual libstdc++
    RUN addgroup -g 1000 appgroup && adduser -u 1000 -G appgroup -s /bin/sh -D appuser

    RUN mkdir -p /usr/src/app && chown -R appuser:appgroup /usr/src/app
    WORKDIR /usr/src/app
    USER appuser

    # Install app dependencies
    COPY --from=base /usr/src/app/start ./
    # Needed for bcrypt
    # COPY --from=base /usr/src/app/node_modules/bcrypt/lib/binding/bcrypt_lib.node ./

    # Exports
    EXPOSE 3000
    CMD [ "./start" ]`

  files['Dockerfile.dev'] = fileTag`
    FROM node:10-alpine

    # Needed for grpc
    # RUN apk --no-cache add --virtual libc6-compat
    # Needed for bcrypt
    # RUN apk --no-cache add --virtual builds-deps build-base python

    # Create app directory
    RUN mkdir -p /usr/src/app
    WORKDIR /usr/src/app

    # Install dependencies
    COPY package*.json ./
    ${options.yarn ? 'COPY yarn.lock .\n' : ''}
    RUN ${options.yarn ? 'yarn' : 'npm install'}

    # Bundle app source
    COPY . .

    # Exports
    USER node
    EXPOSE 3000${options.debug ? ' 9229' : ''}
    CMD [ ${options.yarn ? '"yarn"' : '"npm", "run"'}, "start.dev" ]`

  files['docker-compose.yaml'] = fileTag`
    version: '3'
    services:
      # Application
      ${options.name}:
        image: ${options.name}:dev
        build:
          context: .
          dockerfile: Dockerfile.dev
        depends_on: []
        environment: []
        volumes:
          - ./:/usr/src/app # For nodemon to watch for file changes
          - /usr/src/app/node_modules # So it doesn't use the local node_modules
        ports:
          - '3000:3000' # Application port${
            options.debug
              ? `
          - '9229:9229' # Debug port`
              : ''
          }`
}

if (options.debug) {
  files['.vscode/launch.json'] = {
    version: '0.2.0',
    configurations: [
      {
        name: 'Node: Attach to Node',
        type: 'node',
        request: 'attach',
        port: 9229,
        address: 'localhost',
        restart: true,
        protocol: 'inspector'
      }
    ]
  }
  if (options.docker) {
    files['.vscode/launch.json'].configurations.push({
      name: 'Docker: Attach to Node',
      type: 'node',
      request: 'attach',
      port: 9229,
      address: 'localhost',
      localRoot: '${workspaceFolder}',
      remoteRoot: '/usr/src/app',
      restart: true,
      protocol: 'inspector'
    })
  }
}

if (options.test) {
  devDependencies.add('jest')
  files['jest.config.js'] = fileTag`
    'use strict'

    module.exports = {
      testEnvironment: 'node',
      collectCoverage: true,
      collectCoverageFrom: ['src/**/*.js'],
      coverageThreshold: {
        global: {
          branches: 0,
          functions: 0,
          lines: 0,
          statements: 0
        }
      }
    }`
  files['package.json'].scripts.test = 'jest'
  if (options.typescript) {
    devDependencies.add('ts-jest').add('@types/jest')
    files['jest.config.js'] = fileTag`
      'use strict'

      module.exports = {
        preset: 'ts-jest',
        testEnvironment: 'node',
        collectCoverage: true,
        collectCoverageFrom: ['src/**/*.ts'],
        coverageThreshold: {
          global: {
            branches: 0,
            functions: 0,
            lines: 0,
            statements: 0
          }
        }
      }`
  }
}

const run = async (options, files, dependencies, devDependencies) => {
  await writeFiles(files)
  if (options.git) await spawnPromise('git', ['init'])
  await installDependencies(options.yarn, false, dependencies)
  await installDependencies(options.yarn, true, devDependencies)
}

run(options, files, dependencies, devDependencies).catch(err => {
  console.error(err)
  process.exit(1)
})
